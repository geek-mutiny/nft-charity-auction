const { expect } = require("chai");
const { ethers, waffle } = require("hardhat");

async function getCurrentTimestamp() {
  return (await ethers.provider.getBlock("latest")).timestamp;
}

describe("NFT", function () {
  const tokenId = 1;

  let nft;
  let owner;
  let bidder1;
  let bidder2;
  let endTimestamp;

  beforeEach(async function () {
    endTimestamp = await getCurrentTimestamp() + 20;
    const NFT = await hre.ethers.getContractFactory("NFT");

    [owner, bidder1, bidder2] = await hre.ethers.getSigners();

    nft = await NFT.deploy(owner.address);
    await nft.deployed();

    await expect(nft.createOffer(ethers.utils.parseEther("0.1"), ethers.utils.parseEther("10"), endTimestamp))
      .to.emit(nft, 'CreateOffer').withArgs(
        tokenId, ethers.utils.parseEther("0.1"), ethers.utils.parseEther("10"), endTimestamp
      );
    
    expect(await nft.offerIsActive(tokenId)).to.be.true;
  });

  it("Make a bid", async function () {
    await expect(nft.connect(bidder1).makeBid(tokenId, { value: ethers.utils.parseEther("0.2") }))
      .to.emit(nft, 'MakeBid').withArgs(tokenId, ethers.utils.parseEther("0.2"));
  });

  it("Make max bid and purchase NFT", async function () {
    await expect(nft.connect(bidder1).makeBid(tokenId, { value: ethers.utils.parseEther("10") }))
      .to.emit(nft, 'PurchaseItem').withArgs(bidder1.address, tokenId);
  });

  it("Close offer", async function () {
    await expect(nft.connect(bidder1).makeBid(tokenId, { value: ethers.utils.parseEther("0.2") }))
      .to.emit(nft, 'MakeBid').withArgs(tokenId, ethers.utils.parseEther("0.2"));

    await network.provider.send("evm_mine", [endTimestamp + 10]);

    await expect(nft.connect(bidder1).closeOffer(tokenId))
      .to.emit(nft, 'PurchaseItem').withArgs(bidder1.address, tokenId);

    expect(await nft.offerIsActive(tokenId)).to.be.false;
  });

  it("Close offer as admin", async function () {
    await expect(nft.connect(bidder1).makeBid(tokenId, { value: ethers.utils.parseEther("0.2") }))
      .to.emit(nft, 'MakeBid').withArgs(tokenId, ethers.utils.parseEther("0.2"));

    await network.provider.send("evm_mine", [endTimestamp + 10]);

    await expect(nft.closeOffer(tokenId))
      .to.emit(nft, 'CloseOffer').withArgs(tokenId, bidder1.address, ethers.utils.parseEther("0.2"));

    expect(await nft.offerIsActive(tokenId)).to.be.false;
  });

  it("Outbid", async function () {
    const provider = waffle.provider;
    let bidder1Balance = await provider.getBalance(bidder1.address);

    await expect(nft.connect(bidder1).makeBid(tokenId, { value: ethers.utils.parseEther("0.2") }))
      .to.emit(nft, 'MakeBid').withArgs(tokenId, ethers.utils.parseEther("0.2"));

    bidder1Balance = (await provider.getBalance(bidder1.address)).add(ethers.utils.parseEther("0.2"));

    await expect(nft.connect(bidder2).makeBid(tokenId, { value: ethers.utils.parseEther("0.3") }))
      .to.emit(nft, 'MakeBid').withArgs(tokenId, ethers.utils.parseEther("0.3"));

    expect(await provider.getBalance(bidder1.address)).to.be.equal(bidder1Balance);
  });

  it("Create another offer", async function () {
    const anotherTokenId = 2;
    const anotherEndTimestamp = await getCurrentTimestamp() + 30;

    await expect(nft.createOffer(ethers.utils.parseEther("1"), 0, anotherEndTimestamp))
      .to.emit(nft, 'CreateOffer').withArgs(
        anotherTokenId, ethers.utils.parseEther("1"), 0, anotherEndTimestamp
      );

    await expect(nft.connect(bidder1).makeBid(anotherTokenId, { value: ethers.utils.parseEther("1.1") }))
      .to.emit(nft, 'MakeBid').withArgs(anotherTokenId, ethers.utils.parseEther("1.1"));
  });
});
